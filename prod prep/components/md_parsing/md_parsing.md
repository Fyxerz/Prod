# MD Parsing

## Entity parsing - Check on br
    + Headings (h1)
    	+ If first character == '#' => h entity
    	+ Check how many '#' thre are.
    	+ For each '#' there is =  h + #n
    + Paragraphs (p)
    	+ If first character !== '#', '+', '-', 'num.' => p entity
    	+ Close p element when double br
    + Horizontal rule (hr)
    	+ Apply on only one br
    + Unordered list (ul)
    	+ If first character == '-', '+' => ul
    	+ li auto set until double br
    + Ordered list (ol)
    	+ If first character == num + '.' => ol
    	+ li auto set until double br
    + Image (img)
    	+ If starts with ! ['Alternative text'] (url)
    	+ url links to a file explorer.
    	+ showcase of image immediately below
    + Table (table)
    	+ if table[rows asterisk columns]
    	+ changeable on actual preview because it creates and actual table.

## Inline text entities - Check all characters
	+ Bold (b)
		+ Start on asterisk end at next one.
	+ Italic (i)
		+ Start on double asterisk, end at next one.
	+ Line break (br)
		+ Generated by textarea on enter.
	+ Strikethrough (s)
		+ Start on -- end on --
	+ Underline (u)
		+ Start on double underscore end on next one. 


## Parsing on parsed content
	+ Everything generated on parsing creates a span
	+ span is given a class type depending on parsing of md
	+ parse content within span, not span => if start of span has changed, change class of span.

## Previewing
    + If elements are text entities then syntax highlight markdown key characters and add classes to entities
    + If elements are not text entities or have extra meta information and are block then create a new line just below the original  with preview.
        + If elements are inline then create preview after MD.


Building a custom made MarkDown parser will take longer than anticipated, which means that it will require more resources that are available in order to meet the MVP deadline. While the MD parser was one of the primary focuses for the application, it was only adding an aesthetic value, that while a strong addition, is not essential for the functioning of the product. Because of this, for the MVP the custom made MarkDown parser wiill be replaced with an already made parsing component in order to spend more time in the more critical components that the program needs for it to work.

# Markdown-js

Markdown JS does parsing just fine, and works very fast and with a good node support. It doesn't have any extra features, so applying syntax highlighting or extra features doesn't come naturally. The options system is also a bit counter intuitive and seems over complicated.

# Remarkable

Remarkable works as well as Markdown-js but it has compatibility with hilghlight.js, a syntax highlighting component, which makes it quite extensible. This extension is quite customizable but it also becomes a bit of a mess when working with it as it allows for many options that are not necessary for a markdown editor. The options menu is surprisingly strong and easy to use. It uses an OOP approach that would fit very well as a node component.

# Marked

Marked seems like the most limited component, but it does exactly what it's required for the program. The options menu is very similar to the way markable is built and it also has functionality with highlight.js. However, it understands that the component is only for markdown so focuses all of the options and configuratibility into just markdown. This makes Marked perfect for the job, as it is lightweight, straight to the point and does everything that is required.